<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>T:DM</title>
  
  <subtitle>diary</subtitle>
  <link href="http://mietl.github.io/atom.xml" rel="self"/>
  
  <link href="http://mietl.github.io/"/>
  <updated>2024-05-05T15:21:41.186Z</updated>
  <id>http://mietl.github.io/</id>
  
  <author>
    <name>mietl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pnpm包管理</title>
    <link href="http://mietl.github.io/2024/01/10/build_tools/pnpm/"/>
    <id>http://mietl.github.io/2024/01/10/build_tools/pnpm/</id>
    <published>2024-01-10T15:25:27.000Z</published>
    <updated>2024-05-05T15:21:41.186Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pnpm.io/">pnpm官网</a><br>快速、节省磁盘空间的软件包管理器</p><h2 id="pnpm是如何节省磁盘空间"><a href="#pnpm是如何节省磁盘空间" class="headerlink" title="pnpm是如何节省磁盘空间"></a>pnpm是如何节省磁盘空间</h2><p>使用pnpm安装依赖后，依赖会被存储在硬盘的某一位置，<br>当其他项目在安装依赖时，如果依赖版本存在，包里的文件将被硬链接到该项目、从而不会占用额外的磁盘空间，同时安装速度也得到了提升</p><h4 id="硬链接-hard-link"><a href="#硬链接-hard-link" class="headerlink" title="硬链接(hard link)"></a>硬链接(hard link)</h4><p>在操作系统的文件系统中，多个文件共同使用同一块存储单元   </p><!-- 路径一 project1路径二 project2/node_modules --><p>在使用硬链接的文件时，当修改了路径二中的文件内容时，路径一的文件也随之改变、它们使用的是磁盘中同一块数据  </p><h4 id="软链接-soft-link"><a href="#软链接-soft-link" class="headerlink" title="软链接(soft link)"></a>软链接(soft link)</h4><p>通过符号链接到文件存储位置，指向其他文件的引用，例如快捷方式   </p><h4 id="如何创建硬链接"><a href="#如何创建硬链接" class="headerlink" title="如何创建硬链接"></a>如何创建硬链接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># macos </span><br><span class="hljs-built_in">ln</span> test.js test_hard.js<br><br><span class="hljs-comment"># windows </span><br>mklink /H test.js test_hard.js<br></code></pre></td></tr></table></figure><blockquote><p>这与拷贝文件不同的是，拷贝文件会占用一定的存储空间，它们在磁盘上分别占据不同的空间</p></blockquote><h4 id="如何创建软链接"><a href="#如何创建软链接" class="headerlink" title="如何创建软链接"></a>如何创建软链接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># macos </span><br><span class="hljs-built_in">ln</span> -s test.js test_soft.js<br><br><span class="hljs-comment"># windows </span><br>mklink  test.js test_soft.js<br></code></pre></td></tr></table></figure><blockquote><p>删除源文件后，这个链接就失效了，无法找到引用文件</p></blockquote><h2 id="提高安装速度"><a href="#提高安装速度" class="headerlink" title="提高安装速度"></a>提高安装速度</h2><h3 id="非扁平的-node-modules-目录"><a href="#非扁平的-node-modules-目录" class="headerlink" title="非扁平的 node_modules 目录"></a>非扁平的 node_modules 目录</h3><p><img onerror="imgOnError(this);" data-fancybox="gallery" src="/images/build_tools/node_modules.png" alt="node_modules" data-caption="node_modules" loading="lazy"><br>解决幽灵依赖问题</p><p>通过npm 或 yarn 安装依赖时，所有包都会存放在node_modules下<br>这就导致 Node.js 模块查找策略，你的代码中可以直接访问能找到这些不属于当前项目package.json的依赖包</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://pnpm.io/installation">installation</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># npm 全局安装</span><br>npm install -g pnpm<br><br><span class="hljs-comment"># mac brew</span><br>brew install pnpm<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装package.json中的依赖</span><br>pnpm install<br><br><span class="hljs-comment"># 添加依赖包</span><br>pnpm add<br><br><span class="hljs-comment"># 删除依赖包</span><br>pnpm remove <br><br><span class="hljs-comment"># 执行命令</span><br>pnpm xxx<br><br><span class="hljs-comment"># 查看包仓库存储位置</span><br>pnpm store path<br><span class="hljs-comment"># &gt; /Users/mietl/Library/pnpm/store/v3</span><br></code></pre></td></tr></table></figure><blockquote><p>当pnpm store文件夹越来越大时，可以通过 <code> pnpm store prune</code> 来删除一些未被引用的包，释放空间</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pnpm.io/&quot;&gt;pnpm官网&lt;/a&gt;&lt;br&gt;快速、节省磁盘空间的软件包管理器&lt;/p&gt;
&lt;h2 id=&quot;pnpm是如何节省磁盘空间&quot;&gt;&lt;a href=&quot;#pnpm是如何节省磁盘空间&quot; class=&quot;headerlink&quot; title=&quot;p</summary>
      
    
    
    
    <category term="Tools" scheme="http://mietl.github.io/categories/Tools/"/>
    
    
    <category term="pnpm" scheme="http://mietl.github.io/tags/pnpm/"/>
    
    <category term="包管理" scheme="http://mietl.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Git started</title>
    <link href="http://mietl.github.io/2023/11/21/git/git-started/"/>
    <id>http://mietl.github.io/2023/11/21/git/git-started/</id>
    <published>2023-11-21T08:30:08.000Z</published>
    <updated>2024-05-05T15:21:41.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-started"><a href="#Git-started" class="headerlink" title="Git started"></a>Git started</h1><p>Git 学习</p><h2 id="如何开始使用-Git"><a href="#如何开始使用-Git" class="headerlink" title="如何开始使用 Git"></a>如何开始使用 Git</h2><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>当你要做一些提交时，git 需要知道你是谁，因此你需要配置用户名和邮件地址，他会作为你的提交人信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;mietl&quot;</span>. // 设置用户名<br><br>git config --global user.email <span class="hljs-string">&quot;mietl@icolud.com&quot;</span> // 设置你的邮箱<br></code></pre></td></tr></table></figure><p>使用<code>—global</code>选项后、他将保存到你的系统中，你只需要执行一次。</p><p>添加后你可以使用 <code>git config --list </code>进行查看，你也可以在其他地方配置获取查看他们</p><ul><li><strong>&#x2F;etc&#x2F;.gitconfig</strong><br>系统上所有用户的通用配置 使用 <code>git config </code> 命令时添加<code>—system</code>选项，他会读写这个文件</li><li><strong>.git&#x2F;.gitconfig</strong><br>当前仓库的 .<code>git</code>目录 ,用于当前仓库配置</li><li><strong>~&#x2F;.gitconfig</strong><br>当前用户的 git 配置，操作系统是多用户的,传递<code> —local</code>选项，读写此文件</li></ul><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>通过<code>git init </code>初始化一个仓库用来管理当前项目, 执行后，当前目录下会创建.git 隐藏文件夹。</p><p>默认情况下 git 并不会将你的文件添加到 Git 仓库中，当前仓库还是只是一个空仓库，项目中的文件还未被跟踪，因此你需要手动添加。</p><p>你可以通过<code>git add index.js </code> 来跟踪某个文件的 他会被添加到暂缓区。</p><blockquote><p>暂缓区你可以理解为一个临时放东西的区域</p></blockquote><p>如果你跟踪了某个文件，修改后需要重新添加到<code>暂缓区</code>中 可以使用<code>git add . </code>将所有文件添加到<code>暂缓区</code>中</p><p>对于已经存在的仓库，通过 <code>git clone</code>命令 它会将完整的仓库克隆过来包含历史提交记录</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/meitl.git<br></code></pre></td></tr></table></figure><h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><p>已跟踪的文件，具有不同状态</p><ul><li><code>staged</code> 已经添加到缓存区了</li><li><code>unmodified</code></li><li><code>modifed</code> 修改文件后的状态</li></ul><p>通过 <code>git status</code> 查看文件状态</p><p><img src="/images/git/status.jpg"></p><blockquote><p>Untracked files 表示未跟踪的文件</p></blockquote><p>查看更简洁的状态信息</p><p><code>git status —short</code> 也可以将<code>short</code> 简写为<code>-s </code></p><hr><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>如果你不希望某些文件被上传，创建 <code>.gitignore</code>文件<br>定义一些排除规则，该文件指定的文件或者目录，将不会被 git 跟踪</p><h4 id="文件提交"><a href="#文件提交" class="headerlink" title="文件提交"></a>文件提交</h4><p>将把文件都提交到暂缓区后，通过<code>git commit 命令进行</code>提交，添加 -m 参数 添加你本次提交到信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;hhhh&quot;</span><br></code></pre></td></tr></table></figure><p>通-a 参数可以将所有文件添加到暂存区中省略<code>git add .</code>的步骤</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git commit -a -m <span class="hljs-string">&quot;提交说明&quot;</span><br></code></pre></td></tr></table></figure><hr><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>使用 <code>git log</code> 他会列出所有的历史提交信息<br>包含 SHA-1 校验和(每次提交的唯一标识)、作者的名字和电子邮件地址、提交时间以及提交说明</p><p>查看更加直观的信息<code>git log --pretty=oneline</code><br>当存在分支 <code>git log --pretty=oneline --grap</code> 更易于查看</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>HEAD 是当前分支的指针，他记录着当前处于的版本<br>默认他指向该分支的最后一次提交，你可以通过修改他</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^  // ^上一版本  ^^上一个版本的前一个版本<br><br>git reset --hard HEAD~n   // 回退至前多少次版本<br><br>git reset --hard 7256f72b  // 指定回退至某次提交 commitId;<br></code></pre></td></tr></table></figure><h4 id="远程仓库验证"><a href="#远程仓库验证" class="headerlink" title="远程仓库验证"></a>远程仓库验证</h4><p>你可以通过两种方式对远程仓库进行连接</p><p>当需要对私有仓库进行操作时，Git 服务器需要知道你是谁</p><ol><li>通过 SSH 密钥验证</li></ol><p>通过执行命令生成公钥和私钥</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">ssh-keygen -t ed25519 -C “you email<span class="hljs-string">&quot;       // 通过-C添加注释</span><br></code></pre></td></tr></table></figure><p>你也可以采用不同的加密方式 ，只要 Git 服务器支持</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">ssh-keygen -t rsa -b <span class="hljs-number">2048</span> -C “hhh<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>生成后在你用户文件(&#x2F;Users&#x2F;用户名&#x2F;.ssh)下会产生.ssh 隐藏目录</p><p><img src="/images/git/ssh.jpg"></p><p>后缀名.pub 为公钥文件，将内容配置到 Git 服务器中<br><img src="/images/git/ssh_key.png"></p><p>配置后，在进行提交时，Git 会读取你的私钥文件，与你的帐户配置公钥进行验证。</p><h4 id="与远程仓库建立连接"><a href="#与远程仓库建立连接" class="headerlink" title="与远程仓库建立连接"></a>与远程仓库建立连接</h4><p>默认情况下通过 git clone 命令下载的代码，是已经与远程仓库进行连接的</p><p>当你初始化一个仓库时，如果你需要管理远程仓库</p><p>添加远程地址，让本地仓库和远程仓库建立连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git remote add &lt;name&gt; &lt;url&gt;<br>git remote add origin  https://github.com/mietl/TBlog.git<br></code></pre></td></tr></table></figure><p>添加后 通过<code>git remove</code> 命令查看当前建立的远程连接地址<br>使用<code>-v</code>参数 可以查看更详细的信息<br><img src="/images/git/remote_v.jpg"></p><p>重命名</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git remote rename origin blog<br></code></pre></td></tr></table></figure><p>删除远程地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git remote remove blog<br></code></pre></td></tr></table></figure><h4 id="Git-标签"><a href="#Git-标签" class="headerlink" title="Git 标签"></a>Git 标签</h4><p>当提交历史过多时，如果你想快速找到历史提交中的某次重要版本，你可以为他添加标签</p><p>创建标签</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git tag v1.0.0<br></code></pre></td></tr></table></figure><p>在标签上添加一些附注信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git tag -a v1.0.1 -m <span class="hljs-string">&#x27;fixes&#x27;</span><br></code></pre></td></tr></table></figure><p>将标签上传到远程创建中</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push origin v1.0.0<br></code></pre></td></tr></table></figure><p>上传所有 tags</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push origin --tags<br></code></pre></td></tr></table></figure><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol><li>问题一: 本地分支的上游分支（跟踪分支）</li></ol><p><strong>重现步骤</strong></p><p>在使用<code>git init</code>创建本地仓库后，添加远程仓库连接后<br>执行<code>git pull</code>命令时，会产生<br><img src="/images/git/issue1.png"></p><blockquote><p>git pull 是 git fetch 与 git merge 的结合</p></blockquote><p>原因是<code>git pull 在执行 merge</code>的过程中，由于 Git 存在分支的概念，他并不知道你要合并那条分支<br>你可以明确指定 <code>git pull origin main</code> 具体要合并的分支，但这样在进行 push 操作时也需要明确指定</p><p>你可能会觉得太麻烦，提示中还有另外一个解决方案。</p><p>你可以通过执行下面命令设置本地分支与远程分支的跟踪关系</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch --set-upstream-to=origin/main main<br><span class="hljs-comment"># 最后 main可以省略，默认他会设置当前所在的分支</span><br></code></pre></td></tr></table></figure><p>将当前分支指定上游分支 为远程的 main 分支，指定后 Git 就能知道跟踪是那条分支</p><ol start="2"><li>问题二: 拒绝合并不相干的提交历史 *<em>重现步骤</em><br>通过 Git 服务器创建好远程仓库，添加 README.md 后，<br>创建本地仓库连接远程服务器，合并远程服务器上的 README.md 文件会产生<br><img src="/images/git/issue2.jpg"></li></ol><p>在执行<code>git merge</code>命令时，如果你的远程仓库有提交历史了(已经存在文件了)</p><p>产生原因: Git 默认不允许两个不相干历史进行合并、（没有同一个基础分支历史）<br>如果你依旧想进行合并 添加<code>allow-unrelated-histories</code>参数 来允许提交不相关的提交历史</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git merge --allow-unrelated-histories<br></code></pre></td></tr></table></figure><p>参考链接 <a href="https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories-on-rebase">https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories-on-rebase</a></p><blockquote><p>如果你通过 git clone 项目进行操作的话，可以绕过问题 1 和问题 2，git clone 默认会存在上游分支，克隆下来也存在相关历史</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol><li>命名别名 <code>git config —global alias.br branch</code></li></ol><h4 id="集中式版本控制与分布式版本控制的区别？"><a href="#集中式版本控制与分布式版本控制的区别？" class="headerlink" title="集中式版本控制与分布式版本控制的区别？"></a>集中式版本控制与分布式版本控制的区别？</h4><p><strong>集中式版本控制</strong>： 只在服务器中保存了代码提交的历史记录<br><strong>分布式版本控制</strong>： 客户端与服务器中都有保存完整的历史记录， 在进行克隆操作时会对仓库代码进行完整备份，包括历史记录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-started&quot;&gt;&lt;a href=&quot;#Git-started&quot; class=&quot;headerlink&quot; title=&quot;Git started&quot;&gt;&lt;/a&gt;Git started&lt;/h1&gt;&lt;p&gt;Git 学习&lt;/p&gt;
&lt;h2 id=&quot;如何开始使用-Git&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Git" scheme="http://mietl.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://mietl.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git branch</title>
    <link href="http://mietl.github.io/2023/11/13/git/git-branch/"/>
    <id>http://mietl.github.io/2023/11/13/git/git-branch/</id>
    <published>2023-11-13T22:15:08.000Z</published>
    <updated>2024-05-05T15:21:41.186Z</updated>
    
    <content type="html"><![CDATA[<p>Git 分支学习</p><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>Git 的分支 是指向提交对象的可变指针</p><blockquote><p>HEAD 指向当前分支</p></blockquote><p>你可以创建多个分支，在不同分支上进行提交</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">t1 -&gt; t2  -&gt; t3 (main)<br><br>t1 -&gt; t2   (dev)<br></code></pre></td></tr></table></figure><p>可以很方便在不同的分支中进行开发</p><p><code>main</code> 分支，在进行每次提交后， 他都会指向最后一次提交对象，当你在 <code>mian</code> 分支中进行操作时，<code>dev</code> 不会受影响，<code>dev</code> 依然指向 <code>t2</code>不变</p><p>因此你也可以切换到 dev 中做不同事情</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">t1 -&gt; t2 -&gt; t4 (dev)<br></code></pre></td></tr></table></figure><p><strong>创建分支</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch dev<br></code></pre></td></tr></table></figure><p><strong>查看所有分支</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p><strong>切换分支</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout dev<br></code></pre></td></tr></table></figure><p><strong>创建 dev 并切换到 dev 分支</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout -b dev<br></code></pre></td></tr></table></figure><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch -d dev<br>git branch -D dev  // 强制删除<br></code></pre></td></tr></table></figure><p>查看当前分支与最后一次提交</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch -v<br></code></pre></td></tr></table></figure><h2 id="分支的作用"><a href="#分支的作用" class="headerlink" title="分支的作用"></a>分支的作用</h2><p>例入在开发项目时，开发完小目标功能后，添加 <code>tag</code>进行标记 ，想进行新功能的开发，开发过程中，原先的 tag 版本出现问题，你就可以切换到 tag 版本创建分支完成修复。</p><p>修复后发布新版本，等新功能开发好后，使用 <code> git merge branch-name</code>进行合并</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支也是一种分支结构，和普通的分支一样，只不过在远程</p><p>本地仓库与远程仓库建立连接后,设置上游分支后</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch --set-upstream-to=origin/main<br></code></pre></td></tr></table></figure><p>错误 <strong><u>fatal: the requested upstream branch ‘origin&#x2F;main’ does not exist</u></strong></p><p><img src="/images/git/fatal.png"></p><p>这是因为目前只是与远程仓库建立了的连接，远程仓库中有哪些分支还不知道</p><p>通过<code>git fetch</code>命令来获取最新的远程分支，</p><p><img src="/images/git/fetch-branch.png"></p><p>这样本地就有 <code>origin/main</code> 的分支了</p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>在创建某个分支后，需要共享他时，通过 <code>git push &lt;remote&gt; &lt;branch&gt;</code>推送到远程</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push origin dev<br></code></pre></td></tr></table></figure><h4 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a><strong>跟踪远程分支</strong></h4><blockquote><p>当克隆一个仓库时，会自动创建一个跟踪了 origin&#x2F;main 的本地分支 main</p></blockquote><p>在你创建了本地分支 main 如果想跟踪远程分支，可以通过执行</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">git checkout --track <span class="hljs-tag">&lt;<span class="hljs-name">remote</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">branch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过<code>git clone</code> 下来项目时，本地分支中只会包含 main 分支，当想切换到其他远程分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout --track origin/test<br></code></pre></td></tr></table></figure><p>该命令执行后会先去查看远程有没有这个分支，有的话就创建一个本地 <code>test</code> 分支，并跟踪远程分支 <code>test</code> 同时切换到 <code>test</code> 分支。</p><p>你也可以直接省略 <code>--track </code>参数 直接切换到远程分支，作用时相同的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><strong>删除远程分支</strong></p><p>当不需要远程的某个分支时</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push origin --delete &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>当初始化好本地仓库后，与远程建立连接，远程分支的分支名与本地分支不一致时</p><p>git pull 时拉取代码时，指定上游分支后，提后后</p><p>推送到远程仓库时,产生如下错误,</p><p>本地分支: master<br>远程分支: main</p><p><img onerror="imgOnError(this);" data-fancybox="gallery" src="/images/git/push-default.png" alt="path-default" data-caption="path-default" loading="lazy"></p><p>这个时候就会有疑问了，明明已经设置了上游分支，为什么还需要指定</p><p>这是由于 git push 推送时的默认行为 , 当 <code>push</code> 时会在远程寻找与本地分支同名的进行推送，没有找到就拒绝推送</p><p>常见的默认行为有一下几种，你可以通过配置来修改他</p><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">git config push.<span class="hljs-keyword">default</span> upstream<br></code></pre></td></tr></table></figure><p>推送到上游分支，修改后就能正常推送了</p><h4 id="push-default"><a href="#push-default" class="headerlink" title="push.default"></a>push.default</h4><ol><li><p>nothing<br>没有默认行为，除非明确给出了引用 <code>push origin/main</code>，否则拒绝推送</p></li><li><p>current<br>推送当前分支,到远程同名分支、如果不存在则创建</p></li><li><p>upstream<br>将当前分支推送到上游分支</p></li><li><p>simple (2.0 默认值)<br>将当前分支推送到远程具有相同名称的分支。</p></li></ol><p><a href="https://git-scm.com/docs/git-push#_configuration">参考链接</a></p><p>更常见的做法是通过 <code>git checkout --track mian </code> 来跟踪远程仓库</p><p>他会检查远程有没有 <code>main</code> 分支有的话，创建一个本地 <code>main</code> 分支，跟踪远程分支 <code>main</code>,再切换到 <code>main</code> 分支中</p><p>创建一个同名分支再进行操作，这样可以绕过不必要的麻烦。</p><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4><p>在合并不同分支的方式有两种 <code>git merge</code> 与 <code> git rebase</code></p><p>使用 <code>git rebase</code> 命令你可以将某一分支上的所有修改，移至另外一个分支上， 简单理解就是改变当前分支的<code>base </code></p><p>可以将其想象成在一个分支上的提交拿起来，然后放到另一个分支的最新提交上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout future<br><br>git rebase main<br></code></pre></td></tr></table></figure><p>执行<code>rebase</code>命令 首先会找到<code>future</code>与<code>main</code>分支的共同父提交，将从父提交到 future 分支的所有修改，存储为临时文件，</p><p>以分支 main 为基准，将分支<code>future</code>上的提交一个一个地拿起来，并逐个应用到分支 A 的最新提交上，产生一次<code>future</code>新提交；</p><p>最后回到目标分支 (main) 中进行合并</p><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">git checkout main<br><br>git merge future<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>TIP:</strong> 当我们执行 <code>rebase</code> 操作时，是在要移动的分支中执行 <code>rebase</code>，而不是在目标分支上执行。</p></blockquote><h3 id="rebase-和-merge-的选择"><a href="#rebase-和-merge-的选择" class="headerlink" title="rebase 和 merge 的选择"></a>rebase 和 merge 的选择</h3><p>使用 rebase 与 merge 会产生不同的 Git 历史记录，该如何进行选择呢？</p><ul><li>使用 <code>git merge</code> 在合并分支时，会产生一次新的提交历史<br><img onerror="imgOnError(this);" data-fancybox="gallery" src="/images/git/merge.png" alt="merge" data-caption="merge" loading="lazy"></li><li>使用 <code>git rebase</code> 直接将另外一个分支的修改复制了过来，并不会产生新的提交，这使历史记录更为简洁，并保持线性<br><img onerror="imgOnError(this);" data-fancybox="gallery" src="/images/git/rebase.png" alt="rebase" data-caption="rebase" loading="lazy"></li></ul><p>你可以根据需要选择不同的合并方式</p><blockquote><p>不建议再主要工作的分支中，使用<code>rebase</code>命令，他会造成一些意外的更改记录</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git 分支学习&lt;/p&gt;
&lt;h2 id=&quot;Git-分支&quot;&gt;&lt;a href=&quot;#Git-分支&quot; class=&quot;headerlink&quot; title=&quot;Git 分支&quot;&gt;&lt;/a&gt;Git 分支&lt;/h2&gt;&lt;p&gt;Git 的分支 是指向提交对象的可变指针&lt;/p&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="Git" scheme="http://mietl.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://mietl.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>随想</title>
    <link href="http://mietl.github.io/2023/09/15/sui-xiang/"/>
    <id>http://mietl.github.io/2023/09/15/sui-xiang/</id>
    <published>2023-09-15T11:30:02.000Z</published>
    <updated>2024-05-05T15:21:41.186Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最近发生的事一"><a href="#最近发生的事一" class="headerlink" title="最近发生的事一"></a>最近发生的事一</h4><h4 id="最近发生的事二"><a href="#最近发生的事二" class="headerlink" title="最近发生的事二"></a>最近发生的事二</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最近发生的事一&quot;&gt;&lt;a href=&quot;#最近发生的事一&quot; class=&quot;headerlink&quot; title=&quot;最近发生的事一&quot;&gt;&lt;/a&gt;最近发生的事一&lt;/h4&gt;&lt;h4 id=&quot;最近发生的事二&quot;&gt;&lt;a href=&quot;#最近发生的事二&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="记录" scheme="http://mietl.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 动画</title>
    <link href="http://mietl.github.io/2023/07/18/flutter/animations/"/>
    <id>http://mietl.github.io/2023/07/18/flutter/animations/</id>
    <published>2023-07-18T08:40:39.000Z</published>
    <updated>2024-05-05T15:21:41.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-动画初步"><a href="#1-动画初步" class="headerlink" title="1. 动画初步"></a>1. 动画初步</h2><p>在 Flutter 中，动画可以让应用程序更加生动和具有吸引力。Flutter 中的动画是基于抽象类 <a href="https://api.flutter.dev/flutter/animation/Animation-class.html">Animation</a> 实现的，<br>Animation 对象 用于描述动画状态和取值范围，负责生成动画的值和当前动画的状态<br>通过监听动画的状态变化，我们可以根据当前的动画值来重新构建 widget 更新界面的显示效果。</p><p>与 Animation 一起使用的常用类包括：</p><ul><li><code>AnimationController</code>管理 Animation.</li><li><code>CurvedAnimation</code> 用于定义动画执行曲线。</li><li><code>Tween</code> 用于定义在指定范围内执行动画的值。例如，使用 Tween 定义从红色到蓝色或从 0 到 255 的数值，实现颜色的变化</li><li>使用 <code>Listeners</code> 和 <code>StatusListeners</code> 用于监视动画状态变化</li></ul><h2 id="2-动画控制器（Animation­Controller）"><a href="#2-动画控制器（Animation­Controller）" class="headerlink" title="2. 动画控制器（Animation­Controller）"></a>2. 动画控制器（Animation­Controller）</h2><p><a href="https://api.flutter.dev/flutter/animation/AnimationController-class.html"><code>AnimationController</code></a> AnimationController 是 Animation 的一个特殊子类<br>他可以控制动画开始、停止、向前、向后等操作，还提供了<code>Listeners</code> 和 <code>StatusListeners</code>方法 用于监视动画状态变化</p><p>1.创建动画控制器:</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 创建不启动运行</span><br>AnimationController controller = AnimationController(<br>  duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>), <span class="hljs-comment">// 动画持续时间为2秒</span><br>  <span class="hljs-comment">// reverse: true, 动画方向</span><br>  <span class="hljs-comment">// repeatCount: 3,  动画重复次数</span><br>  vsync: <span class="hljs-keyword">this</span>,  <span class="hljs-comment">// 传入TickerProvider对象</span><br>);<br></code></pre></td></tr></table></figure><p>要启动动画，我们可以调用 AnimationController 的 <code>.forward()</code>方法，它会让动画从头到尾播放。<br>你也可以使用其他的方法来控制动画</p><ul><li><code>stop()</code> 停止动画</li><li><code>reverse()</code> 反向播放动画</li><li><code>dispose()</code> 释放资源</li></ul><p>创建 时 <code>AnimationController</code>，需要一个必传<code>vsync</code> 参数。 <code>vsync</code> 可以防止屏幕外动画消耗不必要的资源。例如锁屏后，处于应用后台时,都不需要执行动画。</p><p>您可以在类定义中添加 <code>SingleTickerProviderStateMixin</code> 将您的有状态对象用作 vsync(垂直同步信号),当有接收到信号时继续执行动画。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_BobState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">tickerApp</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">SingleTickerProviderStateMixin</span> </span>&#123;<br><br>  <span class="hljs-keyword">late</span> Animation&lt;<span class="hljs-built_in">double</span>&gt; animation;<br><br>  <span class="hljs-keyword">late</span> AnimationController controller;<br><br>  <span class="hljs-meta">@override</span><br>  initState() &#123;<br>    controller = AnimationController(duration: <span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>), vsync: <span class="hljs-keyword">this</span>);<br><br>    animation = Tween&lt;<span class="hljs-built_in">double</span>&gt;(begin: <span class="hljs-number">0</span>, end: <span class="hljs-number">300</span>)<br>      .animate(controller)<br>      ..addListener(() &#123;<br>        setState(() &#123; <span class="hljs-comment">/* 这里用来更新界面 */</span> &#125;);<br>    &#125;);<br>    controller.forward();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>      <span class="hljs-keyword">return</span> Center(<br>        child: Container(<br>          margin: <span class="hljs-keyword">const</span> EdgeInsets.symmetric(vertical: <span class="hljs-number">10</span>),<br>          height: animation.value,<br>          width: animation.value,<br>          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;Bob! ！！&#x27;</span>),<br>        ),<br>      );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>使用 SingleTickerProviderStateMixin 时，需要注意他的泛型约束 他必须在 State 类中，并且需要继承自 StatefulWidget</p></blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">mixin</span> SingleTickerProviderStateMixin&lt;T <span class="hljs-keyword">extends</span> StatefulWidget&gt; <span class="hljs-keyword">on</span> State&lt;T&gt; <span class="hljs-keyword">implements</span> TickerProvider<br></code></pre></td></tr></table></figure><p>2.动画状态(AnimationStatus)</p><p>AnimationStatus 类中包含了不同的状态常量，</p><ul><li><code>AnimationStatus.completed</code> 表示动画已完成</li><li><code>AnimationStatus.dismissed</code> 表示动画已消失</li><li><code>AnimationStatus.forward</code> 表示动画正在正向播放</li><li><code>AnimationStatus.reverse</code> 表示动画正在反向播放</li></ul><p>你可以根据这些状态常量来执行相应的操作。</p><p>要监听动画的状态变化，我们可以给 AnimationController 添加一个状态监听器，例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">controller.addStatusListener((status) &#123;<br>  <span class="hljs-comment">// 根据不同的状态做不同的处理</span><br>  <span class="hljs-keyword">if</span> (status == AnimationStatus.completed) &#123;<br>    <span class="hljs-comment">// 动画完成时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animation completed&#x27;</span>);<br>      <span class="hljs-comment">// 可以反向播放或者停止动画</span><br>    controller.reverse();<br>    <span class="hljs-comment">// controller.stop();</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == AnimationStatus.dismissed) &#123;<br>    <span class="hljs-comment">// 动画消失时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animation dismissed&#x27;</span>);<br>    <span class="hljs-comment">// 可以正向播放或者停止动画</span><br>    controller.forward();<br>    <span class="hljs-comment">// controller.stop();</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == AnimationStatus.forward) &#123;<br>    <span class="hljs-comment">// 动画正向播放时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animation forward&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == AnimationStatus.reverse) &#123;<br>    <span class="hljs-comment">// 动画反向播放时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animation reverse&#x27;</span>);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-动画曲线-Curved­Animation"><a href="#3-动画曲线-Curved­Animation" class="headerlink" title="3. 动画曲线 (Curved­Animation)"></a>3. 动画曲线 (Curved­Animation)</h2><p>在动画中，我们可以使用 CurvedAnimation 来定义动画执行曲线。例如，我们可以将动画的执行速度定义为先快后慢，而不是默认的线性曲线（匀速）。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">animation = CurvedAnimation(parent: controller, curve: Curves.easeIn);<br></code></pre></td></tr></table></figure><p>Flutter 中提供了许多常用的曲线，你可以在 <a href="https://api.flutter.dev/flutter/animation/Curves-class.html">Curves</a> 类 ↗ 中找到完整的曲线列表(带有视觉预览)。</p><p><code>CurvedAnimation</code> 包装了它正在修改的对象，因此不需要子类化 AnimationController 对象来实现动画的曲线效果</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">final</span> AnimationController controller = <span class="hljs-title function_ invoke__">AnimationController</span>(<span class="hljs-attr">duration</span>: <span class="hljs-keyword">const</span> <span class="hljs-title function_ invoke__">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">1</span>), <span class="hljs-attr">vsync</span>: this);<br><span class="hljs-keyword">final</span> Animation&lt;<span class="hljs-keyword">double</span>&gt; animation = <span class="hljs-title function_ invoke__">CurvedAnimation</span>(<span class="hljs-attr">parent</span>: controller, <span class="hljs-attr">curve</span>: Curves.easeIn);<br></code></pre></td></tr></table></figure><h2 id="4-Tween"><a href="#4-Tween" class="headerlink" title="4. Tween"></a>4. <a href="https://api.flutter.dev/flutter/animation/Tween-class.html"><code>Tween</code></a></h2><p>默认情况下， <code>AnimationController</code> 对象范围为 0.0 到 1.0。如果您需要不同的范围或不同的数据类型<br>可以通过 Tween 配置动画以插入不同的范围或数据类型</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">tween = Tween&lt;<span class="hljs-built_in">double</span>&gt;(begin: <span class="hljs-number">100.0</span>, end: <span class="hljs-number">200.0</span>);<br></code></pre></td></tr></table></figure><blockquote><p>动画还可以插入除 double 之外的类型，例如 Animation<Color> 或 Animaion<Size></p></blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">colorTween = ColorTween(begin: Colors.transparent, end: Colors.black54);<br></code></pre></td></tr></table></figure><p>要使用 <code>Tween</code> 对象，需要调用 <code>animate()</code> 并传入控制器对象,来创建一个动画对象。例如</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">animation = Tween&lt;<span class="hljs-built_in">double</span>&gt;(begin: <span class="hljs-number">100.0</span>, end: <span class="hljs-number">200.0</span>).animate(controller);<br></code></pre></td></tr></table></figure><p>这样，animation 对象就会根据 <code>Tween</code> 对象的 begin 和 end 值，在 controller 对象的 duration 时间内，从 100.0 变化到 200.0。<br>你可以通过 <code>animation.value</code> 来获取当前的值，或者通过 animation.addListener 来添加监听器，当值变化时执行一些操作。</p><h2 id="AnimatedWidget"><a href="#AnimatedWidget" class="headerlink" title="AnimatedWidget"></a>AnimatedWidget</h2><h2 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h2><h2 id="Hero"><a href="#Hero" class="headerlink" title="Hero"></a>Hero</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-动画初步&quot;&gt;&lt;a href=&quot;#1-动画初步&quot; class=&quot;headerlink&quot; title=&quot;1. 动画初步&quot;&gt;&lt;/a&gt;1. 动画初步&lt;/h2&gt;&lt;p&gt;在 Flutter 中，动画可以让应用程序更加生动和具有吸引力。Flutter 中的动画是基于抽象类 &lt;</summary>
      
    
    
    
    <category term="Flutter" scheme="http://mietl.github.io/categories/Flutter/"/>
    
    
    <category term="Flutter" scheme="http://mietl.github.io/tags/Flutter/"/>
    
  </entry>
  
</feed>
